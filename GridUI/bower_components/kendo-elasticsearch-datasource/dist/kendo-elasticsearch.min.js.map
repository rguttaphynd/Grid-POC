{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///kendo-elasticsearch.min.js","webpack:///webpack/bootstrap 22ef5dd1b699fcf3f1ba","webpack:///./src/kendo-elasticsearch.js","webpack:///./src/sort.js","webpack:///./src/groups.js","webpack:///./src/aggregations.js","webpack:///./src/es-utils.js","webpack:///./src/data-items.js","webpack:///./src/filters.js","webpack:///./src/fields.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireWildcard","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","value","length","err","Array","isArray","TypeError","_sort","sort","_groups","groups","_aggregations","aggregations","_filters","filters","_esUtils","esUtils","_dataItems","dataItems","_fields","fields","data","kendo","ElasticSearchDataSource","DataSource","extend","init","initOptions","Error","transport","read","url","readTransport","dataType","method","contentType","_model","schema","model","esMapping","kendoFieldsFromESMapping","fill","_fields$nestedFields","nestedFields","_fields$nestedFields2","_nestedFields","_subTypes","parameterMap","sortParams","prepareParams","group","columns","esParams","skip","from","take","size","aggregationsOnly","kendo2es","query","filtered","filter","innerHits","esMappingKey","_source","keys","k","esNestedPath","esParentType","esChildType","map","esName","aggs","aggregate","JSON","stringify","parse","response","items","fromHits","hits","doc_count","total","aggregates","es2kendo","grps","serverFiltering","serverSorting","serverPaging","serverAggregates","serverGrouping","fn","fromMapping","_defineProperty","defineProperty","enumerable","configurable","writable","_kendo2es","nestedPath","sortItem","field","esFilterName","order","dir","missing","mode","_prepareParams","arguments","sortArray","constructor","fullSort","forEach","matchingSort","splice","indexOf","concat","previousLevelAggs","previousLevelNestedPath","nextLevelAggs","_kendoGroup2es","nested","path","esFullNestedPath","previousLevelAgg","aggKey","groupAgg","missingAgg","fieldAggregate","groupAggregates","type","esAggName","interval","terms","esGroupAggregates","_parseGroupAggregations","missingNested","groupAggregations","substr","fieldKey","_es2kendo","allGroups","groupAggregation","groupDefs","_esAgg2kendo","fillInGroups","hasSubgroups","buckets","bucketKey","bucket","missingAggregation","groupsMap","groupKeys","key_as_string","count","groupNestedPath","esAggs","aggItem","aggsWrapper","previousPathParts","group_reverse_nested","reverse_nested","split","nestedPathPart","currentPath","join","fullCurrentPath","currentFields","innerHitsFilter","kendoToESAgg","aggType","suffixLength","min","max","sum","average","_innerHits","subTypes","previousLevelInnerHits","_innerHitsFilter","inner_hits","subType","$","logicFilter","or","and","childFilter","not","has_child","has_parent","_fillInGroups","dataItem","fieldValue","Date","groupDefValue","groupDefNextValue","_getValuesFromSource","source","pathParts","values","valueItem","slice","_fromHits","innerPath","hit","hitSource","_id","esNameSplit","duration","moment","startOf","diff","esMultiSplit","esMultiSeparator","splittedItems","innerHitKey","nestedItems","newSplittedDataItems","splittedItem","nestedItem","mergedItem","_splitMultiValues","results","item","itemResults","partialItemResults","val","result","newResult","k2","kendoFilters","logicalConnective","operator","logic","esFilters","esNestedFilters","esFilter","query_string","_filterParam","analyze_wildcard","esNestedFilter","kendoFilter","subtract","format","add","fieldName","esSearchName","fieldEscaped","_asESParameter","valueEscaped","simpleBinaryOperators","eq","search","lt","lte","gt","gte","esOperator","expression","toISOString","replace","match","escapeSearchValueRegexp","escapeValueRegexp","_fromMapping","mapping","prefix","esPrefix","properties","propertyKey","property","curedPropertyKey","asKendoPropertyKey","prefixedName","subNestedPath","index","esSearchSubField","esFilterSubField","esAggSubField","_fill","esStringSubFields","agg","_result"],"mappings":"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","file":"kendo-elasticsearch.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"kendo-elasticsearch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"kendo-elasticsearch\"] = factory();\n\telse\n\t\troot[\"kendo-elasticsearch\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"kendo-elasticsearch\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"kendo-elasticsearch\"] = factory();\n\telse\n\t\troot[\"kendo-elasticsearch\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * A Kendo DataSource that gets its data from ElasticSearch.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Read-only, supports paging, filtering, sorting, grouping and aggregations.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          */\n\t\n\tvar _sort = __webpack_require__(1);\n\t\n\tvar sort = _interopRequireWildcard(_sort);\n\t\n\tvar _groups = __webpack_require__(2);\n\t\n\tvar groups = _interopRequireWildcard(_groups);\n\t\n\tvar _aggregations = __webpack_require__(3);\n\t\n\tvar aggregations = _interopRequireWildcard(_aggregations);\n\t\n\tvar _filters = __webpack_require__(6);\n\t\n\tvar filters = _interopRequireWildcard(_filters);\n\t\n\tvar _esUtils = __webpack_require__(4);\n\t\n\tvar esUtils = _interopRequireWildcard(_esUtils);\n\t\n\tvar _dataItems = __webpack_require__(5);\n\t\n\tvar dataItems = _interopRequireWildcard(_dataItems);\n\t\n\tvar _fields = __webpack_require__(7);\n\t\n\tvar fields = _interopRequireWildcard(_fields);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar data = kendo.data;\n\t\n\tdata.ElasticSearchDataSource = data.DataSource.extend({\n\t  init: function init(initOptions) {\n\t    if (!initOptions) {\n\t      throw new Error('Options are required to use ElasticSearchDataSource');\n\t    }\n\t\n\t    // Prepare the transport to query ES\n\t    // The only required parameter is transport.read.url\n\t    if (initOptions.transport && initOptions.transport.read && initOptions.transport.read.url) {\n\t      var readTransport = initOptions.transport.read;\n\t      readTransport.dataType = readTransport.dataType || 'json';\n\t      readTransport.method = readTransport.method || 'POST';\n\t      readTransport.contentType = readTransport.contentType || 'application/json';\n\t    } else {\n\t      throw new Error('transport.read.url must be set to use ElasticSearchDataSource');\n\t    }\n\t\n\t    var _model = initOptions.schema && initOptions.schema.model;\n\t    if (!_model) {\n\t      throw new Error('transport.schema.model must be set to use ElasticSearchDataSource');\n\t    }\n\t    if (_model.esMapping) {\n\t      _model.fields = _model.fields || {};\n\t      data.ElasticSearchDataSource.kendoFieldsFromESMapping(_model.esMapping, _model, _model.fields);\n\t    } else {\n\t      if (!_model.fields) {\n\t        throw new Error('transport.schema.model.fields/esMapping must be set');\n\t      }\n\t      fields.fill(_model.fields, _model);\n\t    }\n\t\n\t    // Get sets of nesting levels\n\t\n\t    var _fields$nestedFields = fields.nestedFields(fields),\n\t        _fields$nestedFields2 = _slicedToArray(_fields$nestedFields, 2),\n\t        _nestedFields = _fields$nestedFields2[0],\n\t        _subTypes = _fields$nestedFields2[1];\n\t\n\t    // Prepare the content of the query that will be sent to ES\n\t    // based on the kendo data structure\n\t\n\t\n\t    initOptions.transport.parameterMap = function (data) {\n\t      var sortParams = sort.prepareParams(data.sort, data.group, data.columns);\n\t\n\t      var esParams = {};\n\t      if (data.skip) {\n\t        esParams.from = data.skip;\n\t      }\n\t      if (data.take) {\n\t        esParams.size = data.take;\n\t      }\n\t\n\t      if (initOptions.aggregationsOnly) {\n\t        esParams.from = 0;\n\t        esParams.size = 0;\n\t      }\n\t\n\t      // Transform kendo sort params in a ES sort list\n\t      esParams.sort = sort.kendo2es(sortParams, _model.fields);\n\t\n\t      // Transform kendo filters into a ES query using a query_string request\n\t      esParams.query = {\n\t        filtered: {\n\t          filter: filters.kendo2es(data.filter || [], _model.fields)\n\t        }\n\t      };\n\t\n\t      // Add a top level inner_hits definition for nested/parent/child docs\n\t      esParams['inner_hits'] = esUtils.innerHits(_nestedFields, _model.esMappingKey, _subTypes, esParams.sort, esParams.query.filtered.filter);\n\t\n\t      // Fetch only the required list of fields from ES\n\t      esParams._source = Object.keys(_model.fields).filter(function (k) {\n\t        return !_model.fields[k].esNestedPath && !_model.fields[k].esParentType && !_model.fields[k].esChildType;\n\t      }).map(function (k) {\n\t        return _model.fields[k].esName;\n\t      });\n\t\n\t      // Transform kendo aggregations into ES aggregations\n\t      esParams.aggs = aggregations.kendo2es(data.aggregate, _model.fields, _nestedFields, _model.esMappingKey, esParams.query.filtered.filter);\n\t\n\t      // Transform Kendo group instruction into an ES bucket aggregation\n\t      groups.kendo2es(esParams.aggs, data.group, _model.fields, _nestedFields, _model.esMappingKey, esParams.query.filtered.filter);\n\t\n\t      return JSON.stringify(esParams);\n\t    };\n\t\n\t    var schema = initOptions.schema;\n\t\n\t    // Parse the results from elasticsearch to return data items,\n\t    // total and aggregates for Kendo grid\n\t    schema.parse = function (response) {\n\t      var items = dataItems.fromHits(response.hits.hits, _model.fields);\n\t\n\t      // cheat. Root aggregations used as a pseudo buckets with doc_count = total number of results\n\t      // used to process missing counts\n\t      if (response.aggregations) {\n\t        response.aggregations.doc_count = response.hits.total;\n\t      }\n\t      var aggregates = aggregations.es2kendo(response.aggregations);\n\t      var grps = groups.es2kendo(items, response.aggregations, _model.fields, initOptions.aggregationsOnly);\n\t\n\t      return {\n\t        total: response.hits.total,\n\t        data: items,\n\t        aggregates: aggregates,\n\t        groups: grps\n\t      };\n\t    };\n\t\n\t    schema.aggregates = function (response) {\n\t      return response.aggregates;\n\t    };\n\t    schema.groups = function (response) {\n\t      return response.groups;\n\t    };\n\t\n\t    schema.data = schema.data || 'data';\n\t    schema.total = schema.total || 'total';\n\t    schema.model.id = schema.model.id || '_id';\n\t\n\t    initOptions.serverFiltering = true;\n\t    initOptions.serverSorting = true;\n\t    initOptions.serverPaging = true;\n\t    initOptions.serverAggregates = true;\n\t    initOptions.serverGrouping = true;\n\t\n\t    data.DataSource.fn.init.call(this, initOptions);\n\t  }\n\t});\n\t\n\tdata.ElasticSearchDataSource.kendoFieldsFromESMapping = fields.fromMapping;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar prepareParams = exports.prepareParams = _prepareParams;\n\t\n\t// Transform sort instruction into some object suitable for Elasticsearch\n\t// Also deal with sorting the different nesting levels\n\tfunction _kendo2es(sort, fields, nestedPath) {\n\t  return sort.filter(function (sortItem) {\n\t    var field = fields[sortItem.field];\n\t    if (!field) return false;\n\t    return field.esNestedPath === nestedPath || field.esParentType === nestedPath || field.esChildType === nestedPath;\n\t  }).map(function (sortItem) {\n\t    return _defineProperty({}, fields[sortItem.field].esFilterName, {\n\t      order: sortItem.dir,\n\t      // Always put items without the sorted key at the end\n\t      missing: '_last',\n\t      // Deal with sorting items by a property in nested documents\n\t      mode: sortItem.dir === 'asc' ? 'min' : 'max'\n\t    });\n\t  });\n\t};\n\t\n\t// Prepare sort parameters for easier transformation to ES later on\n\tfunction _prepareParams(sort) {\n\t  var groups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t\n\t  // first fix the type of the param that can be object of group\n\t  // we always parse as an array\n\t  // http://docs.telerik.com/kendo-ui/api/javascript/data/datasource#configuration-sort\n\t  var sortArray = [];\n\t  if (sort && sort.constructor === Array) {\n\t    sortArray = sort;\n\t  } else {\n\t    if (sort) {\n\t      sortArray.push(sort);\n\t    }\n\t  }\n\t\n\t  // Sort instructions for the groups are first\n\t  var fullSort = [];\n\t  groups.forEach(function (group) {\n\t    var matchingSort = sortArray.filter(function (sortItem) {\n\t      return sortItem.field === group.field;\n\t    });\n\t    if (matchingSort.length) {\n\t      fullSort.push(matchingSort[0]);\n\t      sortArray.splice(sortArray.indexOf(matchingSort[0]), 1);\n\t    } else {\n\t      // Sort by default\n\t      fullSort.push({\n\t        field: group.field,\n\t        dir: group.dir || 'asc'\n\t      });\n\t    }\n\t  });\n\t\n\t  // Then original sort instructions are added\n\t  fullSort = fullSort.concat(sortArray);\n\t\n\t  return fullSort;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.es2kendo = exports.kendo2es = undefined;\n\t\n\tvar _aggregations = __webpack_require__(3);\n\t\n\tvar aggregations = _interopRequireWildcard(_aggregations);\n\t\n\tvar _dataItems = __webpack_require__(5);\n\t\n\tvar dataItems = _interopRequireWildcard(_dataItems);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar es2kendo = exports.es2kendo = _es2kendo;\n\t\n\t// Transform kendo groups declaration into ES bucket aggregations\n\tfunction _kendo2es(aggs, groups, fields, nestedFields, esMappingKey, filter) {\n\t  var previousLevelAggs = [aggs];\n\t  var previousLevelNestedPath = null;\n\t  groups.forEach(function (group) {\n\t    var field = fields[group.field];\n\t    var nextLevelAggs = _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter);\n\t\n\t    var aggs = {};\n\t    if (field.esNestedPath && field.esNestedPath.indexOf(previousLevelNestedPath) !== 0) {\n\t      aggs[field.esNestedPath + '_nested'] = aggs[field.esNestedPath + '_nested'] || {\n\t        nested: {\n\t          path: field.esFullNestedPath\n\t        },\n\t        aggs: {}\n\t      };\n\t      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_group'] = nextLevelAggs.group;\n\t      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_missing'] = nextLevelAggs.missing;\n\t    } else {\n\t      aggs[group.field + '_group'] = nextLevelAggs.group;\n\t      aggs[group.field + '_missing'] = nextLevelAggs.missing;\n\t    } // 3rd case for nested path that is not child of the previous group\n\t\n\t    previousLevelAggs.forEach(function (previousLevelAgg) {\n\t      Object.keys(aggs).forEach(function (aggKey) {\n\t        previousLevelAgg[aggKey] = aggs[aggKey];\n\t      });\n\t    });\n\t    previousLevelAggs = Object.keys(nextLevelAggs).map(function (aggKey) {\n\t      return nextLevelAggs[aggKey].aggregations;\n\t    });\n\t    previousLevelNestedPath = field.esNestedPath;\n\t  });\n\t}\n\t\n\tfunction _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter) {\n\t  var field = fields[group.field];\n\t  var groupAgg = {};\n\t  var missingAgg = {};\n\t\n\t  // Look for a aggregate defined on group field\n\t  // Used to customize the bucket aggregation for range, histograms, etc.\n\t  var fieldAggregate = void 0;\n\t  var groupAggregates = [];\n\t  (group.aggregates || []).forEach(function (aggregate) {\n\t    // We exclude strings that are not concerned by specific aggregations (only terms buckets)\n\t    // And cause bugs when counting cardinality on own group.\n\t    if (aggregate.field === group.field && field.type !== 'string') {\n\t      fieldAggregate = aggregate;\n\t    } else {\n\t      groupAggregates.push(aggregate);\n\t    }\n\t  });\n\t\n\t  if (fieldAggregate) {\n\t\n\t    // We support date histogramms if a 'interval' key is passed\n\t    // to the group definition\n\t    groupAgg[fieldAggregate.aggregate] = {\n\t      field: field.esAggName\n\t    };\n\t    if (fieldAggregate.interval) {\n\t      groupAgg[fieldAggregate.aggregate].interval = fieldAggregate.interval;\n\t    }\n\t  } else {\n\t\n\t    // Default is a term bucket aggregation\n\t    // if used on a not analyzed field or subfield\n\t    // it will create a group for each value of the field\n\t    groupAgg.terms = {\n\t      field: field.esAggName,\n\t      size: 0\n\t    };\n\t  }\n\t\n\t  missingAgg.missing = {\n\t    field: field.esAggName\n\t  };\n\t\n\t  var esGroupAggregates = aggregations.kendo2es(groupAggregates, fields, nestedFields, esMappingKey, filter, field.esNestedPath);\n\t  groupAgg.aggregations = esGroupAggregates;\n\t  missingAgg.aggregations = esGroupAggregates;\n\t\n\t  return {\n\t    group: groupAgg,\n\t    missing: missingAgg\n\t  };\n\t}\n\t\n\t// Extraction aggregations from ES query result that will be used to group\n\t// data items\n\tfunction _parseGroupAggregations(aggregations, missingNested) {\n\t  var groupAggregations = Object.keys(aggregations).filter(function (aggKey) {\n\t    return aggKey.substr(aggKey.length - 6) === '_group';\n\t  }).map(function (aggKey) {\n\t    var fieldKey = aggKey.substr(0, aggKey.length - 6);\n\t    if (missingNested) {\n\t      aggregations[fieldKey + '_missing'].doc_count += missingNested;\n\t    }\n\t    return {\n\t      group: aggregations[aggKey],\n\t      missing: aggregations[fieldKey + '_missing'],\n\t      fieldKey: fieldKey\n\t    };\n\t  });\n\t\n\t  // extract other group aggregations from nested aggregations\n\t  Object.keys(aggregations).filter(function (aggKey) {\n\t    return aggKey.substr(aggKey.length - 7) === '_nested';\n\t  }).forEach(function (aggKey) {\n\t    // 'missing' count on a nested group aggregation =\n\t    //      'document without nested objects' + 'nested objects with missing field'\n\t    // and 'document without nested objects' is equal to 'number of documents' - 'number of nested documents'\n\t    var missingNested = aggregations.doc_count - aggregations[aggKey].doc_count;\n\t    groupAggregations = groupAggregations.concat(_parseGroupAggregations(aggregations[aggKey], missingNested));\n\t  });\n\t\n\t  return groupAggregations;\n\t}\n\t\n\t// Transform ES bucket aggregations into kendo groups of data items\n\t// See doc here for format of groups:\n\t// http://docs.telerik.com/KENDO-UI/api/javascript/data/datasource#configuration-schema.groups\n\tfunction _es2kendo(items, aggregations, fields, aggregationsOnly) {\n\t  var allGroups = [];\n\t  if (aggregations) {\n\t    var groupAggregations = _parseGroupAggregations(aggregations);\n\t\n\t    // Find aggregations that are grouping aggregations (ie buckets in ES)\n\t    groupAggregations.forEach(function (groupAggregation) {\n\t      var groups = [];\n\t\n\t      var groupDefs = _esAgg2kendo(groupAggregation.group, groupAggregation.missing, groupAggregation.fieldKey);\n\t\n\t      if (!aggregationsOnly) {\n\t        // Then distribute the data items in the groups\n\t        groups = dataItems.fillInGroups(groupDefs, items, fields[groupAggregation.fieldKey]);\n\t      } else {\n\t        groups = groupDefs.keys.map(function (key) {\n\t          return groupDefs.map[key];\n\t        });\n\t      }\n\t\n\t      // Case when there is subgroups. Solve it recursively.\n\t      var hasSubgroups = false;\n\t      if (groupAggregation.group.buckets && groupAggregation.group.buckets[0]) {\n\t        Object.keys(groupAggregation.group.buckets[0]).forEach(function (bucketKey) {\n\t          if (bucketKey.substr(bucketKey.length - 6) === '_group' || bucketKey.substr(bucketKey.length - 7) === '_nested') {\n\t            hasSubgroups = true;\n\t          }\n\t        });\n\t      }\n\t      groups.forEach(function (group) {\n\t        if (hasSubgroups) {\n\t          group.hasSubgroups = true;\n\t          group.items = _es2kendo(group.items, group.bucket, fields, aggregationsOnly);\n\t        }\n\t        delete group.bucket;\n\t      });\n\t\n\t      allGroups = allGroups.concat(groups);\n\t    });\n\t  }\n\t\n\t  return allGroups;\n\t}\n\t\n\t// Transform a single bucket aggregation into kendo groups definitions\n\t// Does not fill up the data items\n\tfunction _esAgg2kendo(groupAggregation, missingAggregation, fieldKey) {\n\t  var groupsMap = {};\n\t  var groupKeys = [];\n\t\n\t  // Each bucket in ES aggregation result is a group\n\t  groupAggregation.buckets.forEach(function (bucket) {\n\t    var bucketKey = bucket.key_as_string || bucket.key;\n\t    groupKeys.push(bucketKey);\n\t    groupsMap[bucketKey] = {\n\t      field: fieldKey,\n\t      value: bucketKey,\n\t      hasSubgroups: false,\n\t      aggregates: aggregations.es2kendo(bucket),\n\t      items: [],\n\t      bucket: bucket\n\t    };\n\t    groupsMap[bucketKey].aggregates[fieldKey] = {\n\t      count: bucket.doc_count\n\t    };\n\t  });\n\t\n\t  // Special case for the missing value\n\t  groupsMap[''] = {\n\t    field: fieldKey,\n\t    value: '',\n\t    hasSubgroups: false,\n\t    aggregates: aggregations.es2kendo(missingAggregation),\n\t    items: [],\n\t    bucket: missingAggregation\n\t  };\n\t  groupsMap[''].aggregates[fieldKey] = {\n\t    count: missingAggregation.doc_count\n\t  };\n\t\n\t  return {\n\t    map: groupsMap,\n\t    keys: groupKeys\n\t  };\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.es2kendo = exports.kendo2es = undefined;\n\t\n\tvar _esUtils = __webpack_require__(4);\n\t\n\tvar esUtils = _interopRequireWildcard(_esUtils);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\tvar es2kendo = exports.es2kendo = _es2kendo;\n\t\n\tvar kendoToESAgg = {\n\t  count: 'cardinality',\n\t  min: 'min',\n\t  max: 'max',\n\t  sum: 'sum',\n\t  average: 'avg'\n\t};\n\t\n\t// Transform kendo aggregates into ES metric aggregations\n\tfunction _kendo2es() {\n\t  var aggregate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\t  var fields = arguments[1];\n\t  var nestedFields = arguments[2];\n\t  var esMappingKey = arguments[3];\n\t  var filter = arguments[4];\n\t  var groupNestedPath = arguments[5];\n\t\n\t  var esAggs = {};\n\t\n\t  aggregate.forEach(function (aggItem) {\n\t    var field = fields[aggItem.field];\n\t    var nestedPath = field.esNestedPath;\n\t    var aggsWrapper = esAggs;\n\t    if (groupNestedPath !== nestedPath) {\n\t      (function () {\n\t        var previousPathParts = [];\n\t        if (groupNestedPath && nestedPath.indexOf(groupNestedPath) !== 0) {\n\t          esAggs.group_reverse_nested = esAggs.group_reverse_nested || {\n\t            reverse_nested: {},\n\t            aggregations: {}\n\t          };\n\t          aggsWrapper = esAggs.group_reverse_nested.aggregations;\n\t        } else if (groupNestedPath) {\n\t          nestedPath = nestedPath.substr(groupNestedPath.length + 1, nestedPath.length);\n\t        }\n\t\n\t        nestedPath.split('.').forEach(function (nestedPathPart) {\n\t          previousPathParts.push(nestedPathPart);\n\t          var currentPath = groupNestedPath ? groupNestedPath + '.' + previousPathParts.join('.') : previousPathParts.join('.');\n\t          var fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n\t          var currentFields = nestedFields[currentPath];\n\t          if (!currentFields) return;\n\t          if (!aggsWrapper[currentPath]) {\n\t            aggsWrapper[currentPath + '_filter_nested'] = aggsWrapper[currentPath + '_filter_nested'] || {\n\t              nested: {\n\t                path: fullCurrentPath\n\t              },\n\t              aggregations: {}\n\t            };\n\t            aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] || {\n\t              filter: esUtils.innerHitsFilter(fullCurrentPath, null, filter),\n\t              aggregations: {}\n\t            };\n\t          }\n\t          aggsWrapper = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'].aggregations;\n\t        });\n\t      })();\n\t    }\n\t\n\t    aggsWrapper[aggItem.field + '_' + aggItem.aggregate] = {};\n\t    aggsWrapper[aggItem.field + '_' + aggItem.aggregate][kendoToESAgg[aggItem.aggregate]] = {\n\t      field: field.esAggName\n\t    };\n\t  });\n\t\n\t  return esAggs;\n\t}\n\t\n\t// Transform aggregation results from a ES query to kendo aggregates\n\tfunction _es2kendo() {\n\t  var aggregations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t  var aggregates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  Object.keys(aggregations).forEach(function (aggKey) {\n\t    if (!aggregations[aggKey]) return;\n\t    ['count', 'min', 'max', 'average', 'sum'].forEach(function (aggType) {\n\t      var suffixLength = aggType.length + 1;\n\t      if (aggKey.substr(aggKey.length - suffixLength) === '_' + aggType) {\n\t        var fieldKey = aggKey.substr(0, aggKey.length - suffixLength);\n\t        aggregates[fieldKey] = aggregates[fieldKey] || {};\n\t        aggregates[fieldKey][aggType] = aggregations[aggKey].value;\n\t      }\n\t    });\n\t\n\t    if (aggKey.substr(aggKey.length - 7) === '_nested' || aggKey.substr(aggKey.length - 7) === '_filter') {\n\t      // recursivity on intermediate levels\n\t      _es2kendo(aggregations[aggKey], aggregates);\n\t    }\n\t  });\n\t  return aggregates;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\t// Some function that work on ES queries to deal with nested levels and other\n\t// difficulties\n\t\n\tvar innerHits = exports.innerHits = _innerHits;\n\tvar innerHitsFilter = exports.innerHitsFilter = _innerHitsFilter;\n\t\n\t// Get a root inner_hits definition to fetch all nested/parent/child docs\n\tfunction _innerHits(nestedFields, esMappingKey, subTypes, sort, filter) {\n\t  var innerHits = {};\n\t  Object.keys(nestedFields).forEach(function (nestedPath) {\n\t    var previousLevelInnerHits = innerHits;\n\t    var previousPathParts = [];\n\t    nestedPath.split('.').forEach(function (nestedPathPart) {\n\t      previousPathParts.push(nestedPathPart);\n\t      var currentPath = previousPathParts.join('.');\n\t      var fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n\t      var currentFields = nestedFields[currentPath];\n\t      if (!currentFields) {\n\t        return;\n\t      }\n\t      if (!previousLevelInnerHits[currentPath]) {\n\t        previousLevelInnerHits[currentPath] = {\n\t          path: _defineProperty({}, fullCurrentPath, {\n\t            _source: currentFields,\n\t            size: 10000,\n\t            sort: sort,\n\t            query: {\n\t              filtered: {\n\t                filter: _innerHitsFilter(fullCurrentPath, null, filter)\n\t              }\n\t            }\n\t          })\n\t        };\n\t      }\n\t      if (currentPath !== nestedPath) {\n\t        previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits = previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits || {};\n\t        previousLevelInnerHits = previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits;\n\t      }\n\t    });\n\t  });\n\t\n\t  Object.keys(subTypes).forEach(function (subType) {\n\t    var currentFields = subTypes[subType];\n\t    innerHits[subType] = {\n\t      type: _defineProperty({}, subType, {\n\t        _source: currentFields,\n\t        size: 10000,\n\t        sort: sort,\n\t        query: {\n\t          filtered: {\n\t            filter: _innerHitsFilter(null, subType, filter)\n\t          }\n\t        }\n\t      })\n\t    };\n\t  });\n\t  return innerHits;\n\t}\n\t\n\t// Traverse the filter to keep only the parts that concern\n\t// a nesting path\n\tfunction _innerHitsFilter(nestedPath, subType, filter) {\n\t  filter = $.extend(true, {}, filter);\n\t  var logicFilter = filter.or || filter.and;\n\t  if (logicFilter) {\n\t    logicFilter.filters = logicFilter.filters.filter(function (childFilter) {\n\t      return childFilter.and || childFilter.or || childFilter.nested && childFilter.nested.path === nestedPath || childFilter.not && childFilter.not.nested && childFilter.not.nested.path === nestedPath || childFilter.has_child && childFilter.has_child.type === subType || childFilter.not && childFilter.not.has_child && childFilter.not.has_child.type === subType || childFilter.has_parent && childFilter.has_parent.type === subType || childFilter.not && childFilter.not.has_parent && childFilter.not.has_parent.type === subType;\n\t    }).map(function (childFilter) {\n\t      if (childFilter.nested) {\n\t        return childFilter.nested.filter;\n\t      } else if (childFilter.not && childFilter.not.nested) {\n\t        return {\n\t          not: childFilter.not.nested.filter\n\t        };\n\t      } else if (childFilter.has_child) {\n\t        return childFilter.has_child.filter;\n\t      } else if (childFilter.not && childFilter.not.has_child) {\n\t        return {\n\t          not: childFilter.not.has_child.filter\n\t        };\n\t      } else if (childFilter.has_parent) {\n\t        return childFilter.has_parent.filter;\n\t      } else if (childFilter.not && childFilter.not.has_parent) {\n\t        return {\n\t          not: childFilter.not.has_parent.filter\n\t        };\n\t      } else {\n\t        return _innerHitsFilter(nestedPath, childFilter);\n\t      }\n\t    });\n\t  }\n\t  return filter;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar fillInGroups = exports.fillInGroups = _fillInGroups;\n\tvar fromHits = exports.fromHits = _fromHits;\n\t\n\t// distribute data items in groups based on a field value\n\tfunction _fillInGroups(groupDefs, dataItems, field) {\n\t  var groups = [];\n\t  dataItems.forEach(function (dataItem) {\n\t    var group = groupDefs.map[dataItem[field.key] || ''];\n\t\n\t    // If no exact match, then we may be in some range aggregation ?\n\t    if (!group) {\n\t      var fieldValue = field.type === 'date' ? new Date(dataItem[field.key]) : dataItem[field.key];\n\t\n\t      for (var i = 0; i < groupDefs.keys.length; i++) {\n\t        var groupDefValue = field.type === 'date' ? new Date(groupDefs.keys[i]) : groupDefs.keys[i];\n\t        if (fieldValue >= groupDefValue) {\n\t          var groupDefNextValue = groupDefs.keys[i + 1] && (field.type === 'date' ? new Date(groupDefs.keys[i + 1]) : groupDefs.keys[i + 1]);\n\t          if (!groupDefNextValue || fieldValue < groupDefNextValue) {\n\t            group = groupDefs.map[groupDefs.keys[i]];\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    if (!group) {\n\t      throw new Error('No group found, val: ' + dataItem[field.key] + ' field: ' + field.key);\n\t    }\n\t    group.items.push(dataItem);\n\t    if (group.items.length === 1) {\n\t      groups.push(group);\n\t    }\n\t  });\n\t  return groups;\n\t}\n\t\n\t// Mimic fetching values from _source as the 'fields' functionality\n\t// would have done it.\n\t// We do not use the native 'fields' due to this bug:\n\t// https://github.com/elastic/elasticsearch/issues/14475\n\tfunction _getValuesFromSource(source, pathParts) {\n\t  var values = [];\n\t  var value = source[pathParts[0]];\n\t  if (value === undefined) {\n\t    return [];\n\t  }\n\t\n\t  if (pathParts.length > 1) {\n\t\n\t    // recursivity is not over, there remain some path parts\n\t    if ($.isArray(value)) {\n\t      value.forEach(function (valueItem) {\n\t        values = values.concat(_getValuesFromSource(valueItem, pathParts.slice(1)));\n\t      });\n\t    } else {\n\t      values = _getValuesFromSource(value, pathParts.slice(1));\n\t    }\n\t  } else {\n\t\n\t    // recursivity, we should be in a leaf value\n\t    if ($.isArray(value)) {\n\t      values = value;\n\t    } else {\n\t      values = [value];\n\t    }\n\t  }\n\t  return values;\n\t}\n\t\n\t// Transform hits from the ES query in to data items for kendo grid\n\t// The difficulty is that hits can contain inner hits and that some\n\t// fields can be multi-valued\n\tfunction _fromHits(hits, fields, innerPath) {\n\t\n\t  var dataItems = [];\n\t  hits.forEach(function (hit) {\n\t    var hitSource = hit._source || {};\n\t    var dataItem = {};\n\t\n\t    dataItem.id = [hit._id];\n\t    Object.keys(fields).filter(function (fieldKey) {\n\t      var field = fields[fieldKey];\n\t\n\t      // Keep only the fields that are part of this nested/parent/child\n\t      if (innerPath === undefined) {\n\t        return !(field.esNestedPath || field.esChildType || field.esParentType);\n\t      } else {\n\t        return field.esNestedPath === innerPath || field.esChildType === innerPath || field.esParentType === innerPath;\n\t      }\n\t    }).forEach(function (fieldKey) {\n\t      var field = fields[fieldKey];\n\t      var values = _getValuesFromSource(hitSource, field.esNameSplit);\n\t\n\t      // special case field that is a date deep down by displayed as a number\n\t      if (field.duration) {\n\t        if (!moment) {\n\t          throw new Error('Working on durations requires to load momentjs library');\n\t        }\n\t      }\n\t\n\t      if (field.duration === 'beforeToday') {\n\t        values = values.map(function (value) {\n\t          return moment().startOf('day').diff(moment(value).startOf('day'), 'days');\n\t        });\n\t      }\n\t\n\t      if (field.duration === 'afterToday') {\n\t        values = values.map(function (value) {\n\t          return moment(value).startOf('day').diff(moment().startOf('day'), 'days');\n\t        });\n\t      }\n\t\n\t      if (values) {\n\t        if (field.esMultiSplit) {\n\t          if (values && values.length) {\n\t            dataItem[fieldKey] = values;\n\t          } else {\n\t            dataItem[fieldKey] = [null];\n\t          }\n\t        } else {\n\t          dataItem[fieldKey] = values.join(field.esMultiSeparator || '\\n');\n\t        }\n\t      }\n\t    });\n\t\n\t    // Multiply and fill items based on nesting levels\n\t    var splittedItems = [dataItem];\n\t    Object.keys(hit.inner_hits || {}).forEach(function (innerHitKey) {\n\t      var nestedItems = _fromHits(hit.inner_hits[innerHitKey].hits.hits, fields, innerHitKey);\n\t      var newSplittedDataItems = [];\n\t      splittedItems.forEach(function (splittedItem) {\n\t        if (nestedItems.length) {\n\t          nestedItems.forEach(function (nestedItem) {\n\t            var mergedItem = {};\n\t            Object.keys(nestedItem).forEach(function (key) {\n\t              mergedItem[key] = nestedItem[key];\n\t            });\n\t            Object.keys(splittedItem).forEach(function (key) {\n\t              mergedItem[key] = splittedItem[key];\n\t            });\n\t            newSplittedDataItems.push(mergedItem);\n\t          });\n\t        } else {\n\t          newSplittedDataItems.push(splittedItem);\n\t        }\n\t      });\n\t      splittedItems = newSplittedDataItems;\n\t    });\n\t\n\t    dataItems = dataItems.concat(splittedItems);\n\t  });\n\t  return _splitMultiValues(dataItems);\n\t}\n\t\n\t// Split lines of data items based on their optionally multipl items\n\t// Example: [{a:[1,2],b:[3]}] -> [{a:1,b:3},{a:2,b:3}]\n\tfunction _splitMultiValues(items) {\n\t  var results = [];\n\t\n\t  // Iterates on items in the array and multiply based on multiple values\n\t  items.forEach(function (item) {\n\t    var itemResults = [{}];\n\t\n\t    // Iterate on properties of item\n\t    Object.keys(item).forEach(function (k) {\n\t      var partialItemResults = [];\n\t\n\t      // Iterate on the multiple values of this property\n\t      if (item[k] && item[k].constructor === Array) {\n\t        item[k].forEach(function (val) {\n\t          itemResults.forEach(function (result) {\n\t\n\t            // Clone the result to create variants with the different values of current key\n\t            var newResult = {};\n\t            Object.keys(result).forEach(function (k2) {\n\t              return newResult[k2] = result[k2];\n\t            });\n\t            newResult[k] = val;\n\t            partialItemResults.push(newResult);\n\t          });\n\t        });\n\t      } else {\n\t        itemResults.forEach(function (result) {\n\t          result[k] = item[k];\n\t          partialItemResults.push(result);\n\t        });\n\t      }\n\t      itemResults = partialItemResults;\n\t    });\n\t\n\t    results = results.concat(itemResults);\n\t  });\n\t  return results;\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar kendo2es = exports.kendo2es = _kendo2es;\n\t\n\t// Transform a tree of kendo filters into a tree of ElasticSearch filters\n\tfunction _kendo2es(kendoFilters, fields) {\n\t  var filters = void 0;\n\t\n\t  // logicalConnective can be \"and\" or \"or\"\n\t  var logicalConnective = 'and';\n\t\n\t  if (kendoFilters.operator) {\n\t    filters = [kendoFilters];\n\t  } else if (kendoFilters.logic) {\n\t    logicalConnective = kendoFilters.logic;\n\t    filters = kendoFilters.filters || [];\n\t  } else if (kendoFilters.constructor === Array) {\n\t    filters = kendoFilters;\n\t  } else {\n\t    throw new Error('Unsupported filter object: ' + kendoFilters);\n\t  }\n\t\n\t  var esFilters = [];\n\t  var esNestedFilters = {};\n\t\n\t  filters.forEach(function (filter) {\n\t    if (filter.logic) {\n\t      esFilters.push(_kendo2es(filter, fields));\n\t    } else {\n\t      var field = fields[filter.field];\n\t      if (!field) {\n\t        throw new Error('Unknown field in filter: ' + filter.field);\n\t      }\n\t      var esFilter = {\n\t        query: {\n\t          query_string: {\n\t            query: _filterParam(filter, fields),\n\t            // support uppercase/lowercase and accents\n\t            analyze_wildcard: true\n\t          }\n\t        }\n\t      };\n\t      if (field.esNestedPath) {\n\t        var esNestedFilter = esNestedFilters[field.esNestedPath] || {\n\t          nested: {\n\t            path: field.esFullNestedPath,\n\t            filter: {}\n\t          }\n\t        };\n\t        esNestedFilter.nested.filter[logicalConnective] = esNestedFilter.nested.filter[logicalConnective] || {\n\t          filters: []\n\t        };\n\t        esNestedFilter.nested.filter[logicalConnective].filters.push(esFilter);\n\t        if (!esNestedFilters[field.esNestedPath]) {\n\t          esFilter = esNestedFilters[field.esNestedPath] = esNestedFilter;\n\t        } else {\n\t          esFilter = null;\n\t        }\n\t      } else if (field.esParentType) {\n\t        esFilter = {\n\t          has_parent: {\n\t            type: field.esParentType,\n\t            filter: esFilter\n\t          }\n\t        };\n\t      } else if (field.esChildType) {\n\t        esFilter = {\n\t          has_child: {\n\t            type: field.esChildType,\n\t            filter: esFilter\n\t          }\n\t        };\n\t      }\n\t\n\t      if (esFilter) {\n\t        esFilters.push(esFilter);\n\t      }\n\t    }\n\t  });\n\t\n\t  var result = {};\n\t  result[logicalConnective] = {\n\t    filters: esFilters\n\t  };\n\t  return result;\n\t}\n\t\n\t// Transform a single kendo filter in a string\n\t// that can be used to compose a ES query_string query\n\tfunction _filterParam(kendoFilter, fields) {\n\t\n\t  // Boolean filter seems to forget the operator sometimes\n\t  kendoFilter.operator = kendoFilter.operator || 'eq';\n\t\n\t  // Use the filter field name except for contains\n\t  // that should use classical search instead of regexp\n\t  var field = fields[kendoFilter.field];\n\t\n\t  // special case field that is a date deep down by displayed as a number\n\t  if (field.duration) {\n\t    if (!moment) {\n\t      throw new Error('Working on durations requires to load momentjs library');\n\t    }\n\t  }\n\t\n\t  if (field.duration === 'beforeToday') {\n\t    kendoFilter.value = moment().startOf('day').subtract(kendoFilter.value, 'days').format();\n\t    if (kendoFilter.operator === 'lt') kendoFilter.operator = 'gt';else if (kendoFilter.operator === 'lte') kendoFilter.operator = 'gte';else if (kendoFilter.operator === 'gt') kendoFilter.operator = 'lt';else if (kendoFilter.operator === 'gte') kendoFilter.operator = 'lte';\n\t  }\n\t\n\t  if (field.duration === 'afterToday') {\n\t    kendoFilter.value = moment().startOf('day').add(kendoFilter.value, 'days').format();\n\t  }\n\t\n\t  var fieldName = void 0;\n\t  if (kendoFilter.operator === 'search') {\n\t    fieldName = field.esSearchName;\n\t  } else {\n\t    fieldName = field.esFilterName;\n\t  }\n\t\n\t  var fieldEscaped = _asESParameter(fieldName);\n\t  var valueEscaped = _asESParameter(kendoFilter.value, kendoFilter.operator);\n\t\n\t  var simpleBinaryOperators = {\n\t    eq: '',\n\t    search: '',\n\t    lt: '<',\n\t    lte: '<=',\n\t    gt: '>',\n\t    gte: '>='\n\t  };\n\t\n\t  if (simpleBinaryOperators[kendoFilter.operator] !== void 0) {\n\t    var esOperator = simpleBinaryOperators[kendoFilter.operator];\n\t    return fieldEscaped + ':' + esOperator + valueEscaped;\n\t  } else {\n\t    var expression = void 0;\n\t    switch (kendoFilter.operator) {\n\t      case 'neq':\n\t        return 'NOT (' + fieldEscaped + ':' + valueEscaped + ')';\n\t      case 'contains':\n\t        return '(' + fieldEscaped + ':*' + valueEscaped + '*)';\n\t      case 'doesnotcontain':\n\t        return 'NOT (' + fieldEscaped + ':*' + valueEscaped + '*)';\n\t      case 'startswith':\n\t        return fieldEscaped + ':' + valueEscaped + '*';\n\t      case 'endswith':\n\t        return fieldEscaped + ':*' + valueEscaped;\n\t      case 'missing':\n\t        if (field.esNestedPath || field.esParentType || field.esChildType) {\n\t          // missing in a nested document should be implemented as a \"not nested exists\"\n\t          // but this is not really doable when mixing with other filters\n\t          // see https://github.com/elastic/elasticsearch/issues/3495\n\t          throw new Error('missing filter is not supported on nested fields');\n\t        }\n\t        expression = '_missing_:' + fieldEscaped;\n\t        if (field.type === 'string') {\n\t          expression += ' OR (' + fieldEscaped + ':\"\")';\n\t        }\n\t        return expression;\n\t      case 'exists':\n\t        expression = '_exists_:' + fieldEscaped;\n\t        if (field.type === 'string') {\n\t          expression += ' AND NOT(' + fieldEscaped + ':\"\")';\n\t        }\n\t        return expression;\n\t      default:\n\t        throw new Error('Unsupported Kendo filter operator: ' + kendoFilter.operator);\n\t    }\n\t  }\n\t}\n\t\n\t// Escape values so that they are suitable as an elasticsearch query_string query parameter\n\tvar escapeValueRegexp = /[+\\-&|!()\\{}\\[\\]^:\"~*?:\\/ ]/g;\n\tvar escapeSearchValueRegexp = /[+\\-&|!()\\{}\\[\\]^:~:\\/]/g;\n\t\n\tfunction _asESParameter(value, operator) {\n\t  if (value.constructor === Date) {\n\t    value = value.toISOString();\n\t  } else if (typeof value === 'boolean' || typeof value === 'number') {\n\t    value = '' + value;\n\t  }\n\t\n\t  // For the special 'search' operator we allow some wildcard and other characters\n\t  if (operator === 'search') {\n\t    value = value.replace('\\\\', '\\\\\\\\');\n\t    if ((value.match(/\"/g) || []).length % 2 === 1) {\n\t      value = value.replace(/\"/g, '\\\\\"');\n\t    }\n\t    value = value.replace(escapeSearchValueRegexp, '\\\\$&');\n\t    return value;\n\t  }\n\t  return value.replace('\\\\', '\\\\\\\\').replace(escapeValueRegexp, '\\\\$&');\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar fromMapping = exports.fromMapping = _fromMapping;\n\tvar fill = exports.fill = _fill;\n\tvar nestedFields = exports.nestedFields = _nestedFields;\n\t\n\t// Transform a mapping definition from ElasticSearch into a kendo fields map\n\t// This utility function is exposed as it can be interesting to use it before instantiating\n\t// the actual datasource\n\t// @param mapping - An elasticsearch mapping\n\tfunction _fromMapping(mapping, model) {\n\t  var fields = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t  var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\t  var esPrefix = arguments[4];\n\t  var nestedPath = arguments[5];\n\t\n\t  Object.keys(mapping.properties || {}).forEach(function (propertyKey) {\n\t    var property = mapping.properties[propertyKey];\n\t    var curedPropertyKey = asKendoPropertyKey(propertyKey);\n\t    var prefixedName = prefix ? prefix + '_' + curedPropertyKey : curedPropertyKey;\n\t    var esName = esPrefix ? esPrefix + '.' + propertyKey : propertyKey;\n\t\n\t    if (property.type === 'nested') {\n\t      // Case where the property is a nested object\n\t      var subNestedPath = nestedPath ? nestedPath + '.' + esName : esName;\n\t      _fromMapping(property, model, fields, prefixedName, '', subNestedPath);\n\t    } else if (property.properties) {\n\t      // Case where the property is a non nested object with properties\n\t      _fromMapping(property, model, fields, prefixedName, esName, nestedPath);\n\t    } else if (property.type === 'object') {\n\t      // Case where the property is a non nested object with zero subproperties. do nothing.\n\t    } else {\n\t      // Finally case of a leaf property\n\t      var field = fields[prefixedName] = fields[prefixedName] || {};\n\t\n\t      // if the field was already defined with a nested path,\n\t      // then we are in the case of field both nested and included in parent\n\t      // then we should not consider it as a real leaf property\n\t      if (!field.esNestedPath) {\n\t        field.type = field.type || property.type;\n\t\n\t        // ES supports a variety of numeric types. In JSON and kendo it is simply 'number'.\n\t        if (['float', 'double', 'integer', 'long', 'short', 'byte'].indexOf(field.type) !== -1) {\n\t          field.type = 'number';\n\t        }\n\t\n\t        // Default is splitting data lines except for string fields\n\t        if (field.type !== 'string') {\n\t          field.esMultiSplit = true;\n\t        }\n\t\n\t        if (nestedPath) {\n\t          field.esNestedPath = nestedPath;\n\t        }\n\t        field.esName = esName;\n\t\n\t        // When the field is not analyzed, the default string subfields should not be applied.\n\t        if (property.index === 'not_analyzed') {\n\t          field.esSearchSubField = null;\n\t          field.esFilterSubField = null;\n\t          field.esAggSubField = null;\n\t        }\n\t      }\n\t    }\n\t  });\n\t\n\t  _fill(fields, model);\n\t\n\t  return fields;\n\t};\n\t\n\t// Associate Kendo field names to ElasticSearch field names.\n\t// We have to allow ElasticSearch field names to be different\n\t// because ES likes an \"@\" and/or dots in field names while Kendo fails on that.\n\t// Filtering and aggregating can be based on a a different field if esFilterName\n\t// or esAggName are defined or on a subfield if esFilterSubField or esAggSubField are defined.\n\t// Typical use case is the main field is analyzed, but it has a subfield that is not\n\t// (or only with a minimal analyzer)\n\tfunction _fill(fields) {\n\t  var model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  for (var k in fields) {\n\t    if (fields.hasOwnProperty(k)) {\n\t      var field = fields[k];\n\t      field.key = k;\n\t      field.esName = field.esName || k;\n\t      field.esNameSplit = field.esName.split('.');\n\t      if (field.esNestedPath) {\n\t        field.esFullNestedPath = field.esNestedPath;\n\t        if (model.esMappingKey) {\n\t          field.esFullNestedPath = model.esMappingKey + '.' + field.esFullNestedPath;\n\t        }\n\t      }\n\t      if (!field.esSearchName) {\n\t        field.esSearchName = field.esName;\n\t        if (field.hasOwnProperty('esSearchSubField')) {\n\t          if (field.esSearchSubField) {\n\t            field.esSearchName += '.' + field.esSearchSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.search) {\n\t          field.esSearchName += '.' + model.esStringSubFields.search;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esSearchName = field.esNestedPath + '.' + field.esSearchName;\n\t        }\n\t      }\n\t      if (!field.esFilterName) {\n\t        field.esFilterName = field.esName;\n\t        if (field.hasOwnProperty('esFilterSubField')) {\n\t          if (field.esFilterSubField) {\n\t            field.esFilterName += '.' + field.esFilterSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.filter) {\n\t          field.esFilterName += '.' + model.esStringSubFields.filter;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esFilterName = field.esNestedPath + '.' + field.esFilterName;\n\t        }\n\t      }\n\t      if (!field.esAggName) {\n\t        field.esAggName = field.esName;\n\t        if (field.hasOwnProperty('esAggSubField')) {\n\t          if (field.esAggSubField) {\n\t            field.esAggName += '.' + field.esAggSubField;\n\t          }\n\t        } else if (field.type === 'string' && model.esStringSubFields && model.esStringSubFields.agg) {\n\t          field.esAggName += '.' + model.esStringSubFields.agg;\n\t        }\n\t        if (field.esNestedPath) {\n\t          field.esAggName = field.esFullNestedPath + '.' + field.esAggName;\n\t        }\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// Get a property key and transform it in a suitable key for kendo\n\t// the constraint is that kendo needs a key suitable for javascript object's dot notation\n\t// i.e a valid js identifier with alphanumeric chars + '_' and '$'\n\tfunction asKendoPropertyKey(value) {\n\t  return value.replace(/[^a-zA-z0-9_$]/g, '_');\n\t}\n\t\n\t// Get sets of nesting levels and matching groups of fields\n\tfunction _nestedFields(fields) {\n\t  var _result = {};\n\t  var _subTypes = {};\n\t  Object.keys(fields).forEach(function (fieldKey) {\n\t    var field = fields[fieldKey];\n\t    if (field.esNestedPath) {\n\t      _result[field.esNestedPath] = _result[field.esNestedPath] || [];\n\t      _result[field.esNestedPath].push(field.esName);\n\t    }\n\t    if (field.esParentType) {\n\t      _subTypes[field.esParentType] = _subTypes[field.esParentType] || [];\n\t      _subTypes[field.esParentType].push(field.esName);\n\t    }\n\t    if (field.esChildType) {\n\t      _subTypes[field.esChildType] = _subTypes[field.esChildType] || [];\n\t      _subTypes[field.esChildType].push(field.esName);\n\t    }\n\t  });\n\t\n\t  return [_result, _subTypes];\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** kendo-elasticsearch.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 22ef5dd1b699fcf3f1ba\n **/","/**\n * A Kendo DataSource that gets its data from ElasticSearch.\n *\n * Read-only, supports paging, filtering, sorting, grouping and aggregations.\n */\n\nimport * as sort from './sort';\nimport * as groups from './groups';\nimport * as aggregations from './aggregations';\nimport * as filters from './filters';\nimport * as esUtils from './es-utils';\nimport * as dataItems from './data-items';\nimport * as fields from './fields';\n\nconst data = kendo.data;\n\ndata.ElasticSearchDataSource = data.DataSource.extend({\n  init(initOptions) {\n    if (!initOptions) {\n      throw new Error('Options are required to use ElasticSearchDataSource');\n    }\n\n    // Prepare the transport to query ES\n    // The only required parameter is transport.read.url\n    if (initOptions.transport && initOptions.transport.read && initOptions.transport.read.url) {\n      const readTransport = initOptions.transport.read;\n      readTransport.dataType = readTransport.dataType || 'json';\n      readTransport.method = readTransport.method || 'POST';\n      readTransport.contentType = readTransport.contentType || 'application/json';\n    } else {\n      throw new Error('transport.read.url must be set to use ElasticSearchDataSource');\n    }\n\n    const _model = initOptions.schema && initOptions.schema.model;\n    if (!_model) {\n      throw new Error('transport.schema.model must be set to use ElasticSearchDataSource');\n    }\n    if (_model.esMapping) {\n      _model.fields = _model.fields || {};\n      data.ElasticSearchDataSource.kendoFieldsFromESMapping(\n        _model.esMapping, _model, _model.fields);\n    } else {\n      if (!_model.fields) {\n        throw new Error('transport.schema.model.fields/esMapping must be set');\n      }\n      fields.fill(_model.fields, _model);\n    }\n\n    // Get sets of nesting levels\n    const [_nestedFields, _subTypes] = fields.nestedFields(fields);\n\n    // Prepare the content of the query that will be sent to ES\n    // based on the kendo data structure\n    initOptions.transport.parameterMap = function (data) {\n      const sortParams = sort.prepareParams(data.sort, data.group, data.columns);\n\n      const esParams = {};\n      if (data.skip) {\n        esParams.from = data.skip;\n      }\n      if (data.take) {\n        esParams.size = data.take;\n      }\n\n      if (initOptions.aggregationsOnly) {\n        esParams.from = 0;\n        esParams.size = 0;\n      }\n\n      // Transform kendo sort params in a ES sort list\n      esParams.sort = sort.kendo2es(sortParams, _model.fields);\n\n      // Transform kendo filters into a ES query using a query_string request\n      esParams.query = {\n        filtered: {\n          filter: filters.kendo2es(data.filter || [], _model.fields)\n        }\n      };\n\n      // Add a top level inner_hits definition for nested/parent/child docs\n      esParams['inner_hits'] = esUtils.innerHits(\n        _nestedFields,\n        _model.esMappingKey,\n        _subTypes,\n        esParams.sort,\n        esParams.query.filtered.filter\n      );\n\n      // Fetch only the required list of fields from ES\n      esParams._source = Object.keys(_model.fields)\n        .filter(k =>\n          !_model.fields[k].esNestedPath &&\n          !_model.fields[k].esParentType &&\n          !_model.fields[k].esChildType)\n        .map(k => _model.fields[k].esName);\n\n      // Transform kendo aggregations into ES aggregations\n      esParams.aggs = aggregations.kendo2es(\n        data.aggregate,\n        _model.fields,\n        _nestedFields,\n        _model.esMappingKey,\n        esParams.query.filtered.filter\n      );\n\n      // Transform Kendo group instruction into an ES bucket aggregation\n      groups.kendo2es(\n        esParams.aggs,\n        data.group,\n        _model.fields,\n        _nestedFields,\n        _model.esMappingKey,\n        esParams.query.filtered.filter\n      );\n\n      return JSON.stringify(esParams);\n    };\n\n    const schema = initOptions.schema;\n\n    // Parse the results from elasticsearch to return data items,\n    // total and aggregates for Kendo grid\n    schema.parse = function (response) {\n      const items = dataItems.fromHits(response.hits.hits, _model.fields);\n\n      // cheat. Root aggregations used as a pseudo buckets with doc_count = total number of results\n      // used to process missing counts\n      if (response.aggregations) {\n        response.aggregations.doc_count = response.hits.total;\n      }\n      const aggregates = aggregations.es2kendo(response.aggregations);\n      const grps = groups.es2kendo(items, response.aggregations, _model.fields, initOptions.aggregationsOnly);\n\n      return {\n        total: response.hits.total,\n        data: items,\n        aggregates: aggregates,\n        groups: grps\n      };\n    };\n\n    schema.aggregates = response => response.aggregates;\n    schema.groups = response => response.groups;\n\n    schema.data = schema.data || 'data';\n    schema.total = schema.total || 'total';\n    schema.model.id = schema.model.id || '_id';\n\n    initOptions.serverFiltering = true;\n    initOptions.serverSorting = true;\n    initOptions.serverPaging = true;\n    initOptions.serverAggregates = true;\n    initOptions.serverGrouping = true;\n\n    data.DataSource.fn.init.call(this, initOptions);\n  }\n});\n\ndata.ElasticSearchDataSource.kendoFieldsFromESMapping = fields.fromMapping;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/kendo-elasticsearch.js\n **/","export const kendo2es = _kendo2es;\nexport const prepareParams = _prepareParams;\n\n// Transform sort instruction into some object suitable for Elasticsearch\n// Also deal with sorting the different nesting levels\nfunction _kendo2es(sort, fields, nestedPath) {\n  return sort.filter(sortItem => {\n    const field = fields[sortItem.field];\n    if (!field) return false;\n    return field.esNestedPath === nestedPath ||\n      field.esParentType === nestedPath ||\n      field.esChildType === nestedPath;\n  }).map(sortItem => {\n    return {\n      [fields[sortItem.field].esFilterName]: {\n        order: sortItem.dir,\n        // Always put items without the sorted key at the end\n        missing: '_last',\n        // Deal with sorting items by a property in nested documents\n        mode: sortItem.dir === 'asc' ? 'min' : 'max'\n      }\n    };\n  });\n};\n\n// Prepare sort parameters for easier transformation to ES later on\nfunction _prepareParams(sort, groups = []) {\n  // first fix the type of the param that can be object of group\n  // we always parse as an array\n  // http://docs.telerik.com/kendo-ui/api/javascript/data/datasource#configuration-sort\n  let sortArray = [];\n  if (sort && sort.constructor === Array) {\n    sortArray = sort;\n  } else {\n    if (sort) {\n      sortArray.push(sort);\n    }\n  }\n\n  // Sort instructions for the groups are first\n  let fullSort = [];\n  groups.forEach(group => {\n    const matchingSort = sortArray.filter(function (sortItem) {\n      return sortItem.field === group.field;\n    });\n    if (matchingSort.length) {\n      fullSort.push(matchingSort[0]);\n      sortArray.splice(sortArray.indexOf(matchingSort[0]), 1);\n    } else {\n      // Sort by default\n      fullSort.push({\n        field: group.field,\n        dir: group.dir || 'asc'\n      });\n    }\n  });\n\n  // Then original sort instructions are added\n  fullSort = fullSort.concat(sortArray);\n\n  return fullSort;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/sort.js\n **/","import * as aggregations from './aggregations';\nimport * as dataItems from './data-items';\nexport const kendo2es = _kendo2es;\nexport const es2kendo = _es2kendo;\n\n// Transform kendo groups declaration into ES bucket aggregations\nfunction _kendo2es(aggs, groups, fields, nestedFields, esMappingKey, filter) {\n  let previousLevelAggs = [aggs];\n  let previousLevelNestedPath = null;\n  groups.forEach(group => {\n    const field = fields[group.field];\n    const nextLevelAggs = _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter);\n\n    const aggs = {};\n    if (field.esNestedPath && field.esNestedPath.indexOf(previousLevelNestedPath) !== 0) {\n      aggs[field.esNestedPath + '_nested'] = aggs[field.esNestedPath + '_nested'] || {\n        nested: {\n          path: field.esFullNestedPath\n        },\n        aggs: {}\n      };\n      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_group'] = nextLevelAggs.group;\n      aggs[field.esNestedPath + '_nested'].aggs[group.field + '_missing'] = nextLevelAggs.missing;\n    } else {\n      aggs[group.field + '_group'] = nextLevelAggs.group;\n      aggs[group.field + '_missing'] = nextLevelAggs.missing;\n    } // 3rd case for nested path that is not child of the previous group\n\n    previousLevelAggs.forEach(previousLevelAgg => {\n      Object.keys(aggs).forEach(aggKey => {\n        previousLevelAgg[aggKey] = aggs[aggKey];\n      });\n    });\n    previousLevelAggs = Object.keys(nextLevelAggs).map(aggKey => {\n      return nextLevelAggs[aggKey].aggregations;\n    });\n    previousLevelNestedPath = field.esNestedPath;\n  });\n}\n\nfunction _kendoGroup2es(group, fields, nestedFields, esMappingKey, filter) {\n  const field = fields[group.field];\n  const groupAgg = {};\n  const missingAgg = {};\n\n  // Look for a aggregate defined on group field\n  // Used to customize the bucket aggregation for range, histograms, etc.\n  let fieldAggregate;\n  const groupAggregates = [];\n  (group.aggregates || []).forEach(aggregate => {\n    // We exclude strings that are not concerned by specific aggregations (only terms buckets)\n    // And cause bugs when counting cardinality on own group.\n    if (aggregate.field === group.field && field.type !== 'string') {\n      fieldAggregate = aggregate;\n    } else {\n      groupAggregates.push(aggregate);\n    }\n  });\n\n  if (fieldAggregate) {\n\n    // We support date histogramms if a 'interval' key is passed\n    // to the group definition\n    groupAgg[fieldAggregate.aggregate] = {\n      field: field.esAggName\n    };\n    if (fieldAggregate.interval) {\n      groupAgg[fieldAggregate.aggregate].interval = fieldAggregate.interval;\n    }\n  } else {\n\n    // Default is a term bucket aggregation\n    // if used on a not analyzed field or subfield\n    // it will create a group for each value of the field\n    groupAgg.terms = {\n      field: field.esAggName,\n      size: 0\n    };\n  }\n\n  missingAgg.missing = {\n    field: field.esAggName\n  };\n\n  const esGroupAggregates = aggregations.kendo2es(\n    groupAggregates,\n    fields,\n    nestedFields,\n    esMappingKey,\n    filter,\n    field.esNestedPath\n  );\n  groupAgg.aggregations = esGroupAggregates;\n  missingAgg.aggregations = esGroupAggregates;\n\n  return {\n    group: groupAgg,\n    missing: missingAgg\n  };\n}\n\n// Extraction aggregations from ES query result that will be used to group\n// data items\nfunction _parseGroupAggregations(aggregations, missingNested) {\n  let groupAggregations = Object.keys(aggregations).filter(aggKey => {\n    return aggKey.substr(aggKey.length - 6) === '_group';\n  }).map(aggKey => {\n    const fieldKey = aggKey.substr(0, aggKey.length - 6);\n    if (missingNested) {\n      aggregations[fieldKey + '_missing'].doc_count += missingNested;\n    }\n    return {\n      group: aggregations[aggKey],\n      missing: aggregations[fieldKey + '_missing'],\n      fieldKey: fieldKey\n    };\n  });\n\n  // extract other group aggregations from nested aggregations\n  Object.keys(aggregations)\n    .filter(aggKey => aggKey.substr(aggKey.length - 7) === '_nested')\n    .forEach(aggKey => {\n      // 'missing' count on a nested group aggregation =\n      //      'document without nested objects' + 'nested objects with missing field'\n      // and 'document without nested objects' is equal to 'number of documents' - 'number of nested documents'\n      const missingNested = aggregations.doc_count - aggregations[aggKey].doc_count;\n      groupAggregations =\n        groupAggregations.concat(_parseGroupAggregations(aggregations[aggKey], missingNested));\n    });\n\n  return groupAggregations;\n}\n\n// Transform ES bucket aggregations into kendo groups of data items\n// See doc here for format of groups:\n// http://docs.telerik.com/KENDO-UI/api/javascript/data/datasource#configuration-schema.groups\nfunction _es2kendo(items, aggregations, fields, aggregationsOnly) {\n  let allGroups = [];\n  if (aggregations) {\n    const groupAggregations = _parseGroupAggregations(aggregations);\n\n    // Find aggregations that are grouping aggregations (ie buckets in ES)\n    groupAggregations.forEach(groupAggregation => {\n      let groups = [];\n\n      const groupDefs = _esAgg2kendo(\n        groupAggregation.group,\n        groupAggregation.missing,\n        groupAggregation.fieldKey);\n\n      if (!aggregationsOnly) {\n        // Then distribute the data items in the groups\n        groups = dataItems.fillInGroups(groupDefs, items, fields[groupAggregation.fieldKey]);\n      } else {\n        groups = groupDefs.keys.map(function (key) {\n          return groupDefs.map[key];\n        });\n      }\n\n      // Case when there is subgroups. Solve it recursively.\n      let hasSubgroups = false;\n      if (groupAggregation.group.buckets && groupAggregation.group.buckets[0]) {\n        Object.keys(groupAggregation.group.buckets[0]).forEach(bucketKey => {\n          if (bucketKey.substr(bucketKey.length - 6) === '_group' ||\n            bucketKey.substr(bucketKey.length - 7) === '_nested') {\n            hasSubgroups = true;\n          }\n        });\n      }\n      groups.forEach(group => {\n        if (hasSubgroups) {\n          group.hasSubgroups = true;\n          group.items = _es2kendo(group.items, group.bucket, fields, aggregationsOnly);\n        }\n        delete group.bucket;\n      });\n\n      allGroups = allGroups.concat(groups);\n    });\n  }\n\n  return allGroups;\n}\n\n// Transform a single bucket aggregation into kendo groups definitions\n// Does not fill up the data items\nfunction _esAgg2kendo(groupAggregation, missingAggregation, fieldKey) {\n  const groupsMap = {};\n  const groupKeys = [];\n\n  // Each bucket in ES aggregation result is a group\n  groupAggregation.buckets.forEach(bucket => {\n    const bucketKey = bucket.key_as_string || bucket.key;\n    groupKeys.push(bucketKey);\n    groupsMap[bucketKey] = {\n      field: fieldKey,\n      value: bucketKey,\n      hasSubgroups: false,\n      aggregates: aggregations.es2kendo(bucket),\n      items: [],\n      bucket: bucket\n    };\n    groupsMap[bucketKey].aggregates[fieldKey] = {\n      count: bucket.doc_count\n    };\n  });\n\n  // Special case for the missing value\n  groupsMap[''] = {\n    field: fieldKey,\n    value: '',\n    hasSubgroups: false,\n    aggregates: aggregations.es2kendo(missingAggregation),\n    items: [],\n    bucket: missingAggregation\n  };\n  groupsMap[''].aggregates[fieldKey] = {\n    count: missingAggregation.doc_count\n  };\n\n  return {\n    map: groupsMap,\n    keys: groupKeys\n  };\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/groups.js\n **/","import * as esUtils from './es-utils';\nexport const kendo2es = _kendo2es;\nexport const es2kendo = _es2kendo;\n\nconst kendoToESAgg = {\n  count: 'cardinality',\n  min: 'min',\n  max: 'max',\n  sum: 'sum',\n  average: 'avg'\n};\n\n// Transform kendo aggregates into ES metric aggregations\nfunction _kendo2es(aggregate = [], fields, nestedFields, esMappingKey, filter, groupNestedPath) {\n  const esAggs = {};\n\n  aggregate.forEach(aggItem => {\n    const field = fields[aggItem.field];\n    let nestedPath = field.esNestedPath;\n    let aggsWrapper = esAggs;\n    if (groupNestedPath !== nestedPath) {\n      const previousPathParts = [];\n      if (groupNestedPath && nestedPath.indexOf(groupNestedPath) !== 0) {\n        esAggs.group_reverse_nested = esAggs.group_reverse_nested || {\n          reverse_nested: {},\n          aggregations: {}\n        };\n        aggsWrapper = esAggs.group_reverse_nested.aggregations;\n      } else if (groupNestedPath) {\n        nestedPath = nestedPath.substr(groupNestedPath.length + 1, nestedPath.length);\n      }\n\n      nestedPath.split('.').forEach(nestedPathPart => {\n        previousPathParts.push(nestedPathPart);\n        const currentPath = groupNestedPath ?\n          groupNestedPath + '.' + previousPathParts.join('.') :\n          previousPathParts.join('.');\n        const fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n        const currentFields = nestedFields[currentPath];\n        if (!currentFields) return;\n        if (!aggsWrapper[currentPath]) {\n          aggsWrapper[currentPath + '_filter_nested'] = aggsWrapper[currentPath + '_filter_nested'] || {\n            nested: {\n              path: fullCurrentPath\n            },\n            aggregations: {}\n          };\n          aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] =\n            aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'] || {\n              filter: esUtils.innerHitsFilter(fullCurrentPath, null, filter),\n              aggregations: {}\n            };\n        }\n        aggsWrapper = aggsWrapper[currentPath + '_filter_nested'].aggregations[currentPath + '_filter'].aggregations;\n      });\n    }\n\n    aggsWrapper[aggItem.field + '_' + aggItem.aggregate] = {};\n    aggsWrapper[aggItem.field + '_' + aggItem.aggregate][kendoToESAgg[aggItem.aggregate]] = {\n      field: field.esAggName\n    };\n  });\n\n  return esAggs;\n}\n\n// Transform aggregation results from a ES query to kendo aggregates\nfunction _es2kendo(aggregations = {}, aggregates = {}) {\n  Object.keys(aggregations).forEach(aggKey => {\n    if (!aggregations[aggKey]) return;\n    ['count', 'min', 'max', 'average', 'sum'].forEach(aggType => {\n      const suffixLength = aggType.length + 1;\n      if (aggKey.substr(aggKey.length - suffixLength) === '_' + aggType) {\n        const fieldKey = aggKey.substr(0, aggKey.length - suffixLength);\n        aggregates[fieldKey] = aggregates[fieldKey] || {};\n        aggregates[fieldKey][aggType] = aggregations[aggKey].value;\n      }\n    });\n\n    if (aggKey.substr(aggKey.length - 7) === '_nested' || aggKey.substr(aggKey.length - 7) === '_filter') {\n      // recursivity on intermediate levels\n      _es2kendo(aggregations[aggKey], aggregates);\n    }\n\n  });\n  return aggregates;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/aggregations.js\n **/","// Some function that work on ES queries to deal with nested levels and other\n// difficulties\n\nexport const innerHits = _innerHits;\nexport const innerHitsFilter = _innerHitsFilter;\n\n// Get a root inner_hits definition to fetch all nested/parent/child docs\nfunction _innerHits(nestedFields, esMappingKey, subTypes, sort, filter) {\n  const innerHits = {};\n  Object.keys(nestedFields).forEach(nestedPath => {\n    let previousLevelInnerHits = innerHits;\n    const previousPathParts = [];\n    nestedPath.split('.').forEach(nestedPathPart => {\n      previousPathParts.push(nestedPathPart);\n      const currentPath = previousPathParts.join('.');\n      const fullCurrentPath = esMappingKey ? esMappingKey + '.' + currentPath : currentPath;\n      const currentFields = nestedFields[currentPath];\n      if (!currentFields) {\n        return;\n      }\n      if (!previousLevelInnerHits[currentPath]) {\n        previousLevelInnerHits[currentPath] = {\n          path: {\n            [fullCurrentPath]: {\n              _source: currentFields,\n              size: 10000,\n              sort: sort,\n              query: {\n                filtered: {\n                  filter: _innerHitsFilter(fullCurrentPath, null, filter)\n                }\n              }\n            }\n          }\n        };\n      }\n      if (currentPath !== nestedPath) {\n        previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits =\n          previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits || {};\n        previousLevelInnerHits =\n          previousLevelInnerHits[currentPath].path[fullCurrentPath].inner_hits;\n      }\n    });\n  });\n\n  Object.keys(subTypes).forEach(subType => {\n    const currentFields = subTypes[subType];\n    innerHits[subType] = {\n      type: {\n        [subType]: {\n          _source: currentFields,\n          size: 10000,\n          sort: sort,\n          query: {\n            filtered: {\n              filter: _innerHitsFilter(null, subType, filter)\n            }\n          }\n        }\n      }\n    };\n  });\n  return innerHits;\n}\n\n// Traverse the filter to keep only the parts that concern\n// a nesting path\nfunction _innerHitsFilter(nestedPath, subType, filter) {\n  filter = $.extend(true, {}, filter);\n  const logicFilter = filter.or || filter.and;\n  if (logicFilter) {\n    logicFilter.filters = logicFilter.filters.filter(childFilter => {\n      return childFilter.and || childFilter.or ||\n        (childFilter.nested && childFilter.nested.path === nestedPath) ||\n        (childFilter.not && childFilter.not.nested && childFilter.not.nested.path === nestedPath) ||\n        (childFilter.has_child && childFilter.has_child.type === subType) ||\n        (childFilter.not && childFilter.not.has_child && childFilter.not.has_child.type === subType) ||\n        (childFilter.has_parent && childFilter.has_parent.type === subType) ||\n        (childFilter.not && childFilter.not.has_parent && childFilter.not.has_parent.type === subType);\n    }).map(childFilter => {\n      if (childFilter.nested) {\n        return childFilter.nested.filter;\n      } else if (childFilter.not && childFilter.not.nested) {\n        return {\n          not: childFilter.not.nested.filter\n        };\n      } else if (childFilter.has_child) {\n        return childFilter.has_child.filter;\n      } else if (childFilter.not && childFilter.not.has_child) {\n        return {\n          not: childFilter.not.has_child.filter\n        };\n      } else if (childFilter.has_parent) {\n        return childFilter.has_parent.filter;\n      } else if (childFilter.not && childFilter.not.has_parent) {\n        return {\n          not: childFilter.not.has_parent.filter\n        };\n      } else {\n        return _innerHitsFilter(nestedPath, childFilter);\n      }\n    });\n  }\n  return filter;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/es-utils.js\n **/","export const fillInGroups = _fillInGroups;\nexport const fromHits = _fromHits;\n\n// distribute data items in groups based on a field value\nfunction _fillInGroups(groupDefs, dataItems, field) {\n  const groups = [];\n  dataItems.forEach(function (dataItem) {\n    let group = groupDefs.map[dataItem[field.key] || ''];\n\n    // If no exact match, then we may be in some range aggregation ?\n    if (!group) {\n      const fieldValue = field.type === 'date' ? new Date(dataItem[field.key]) : dataItem[field.key];\n\n      for (let i = 0; i < groupDefs.keys.length; i++) {\n        const groupDefValue = field.type === 'date' ? new Date(groupDefs.keys[i]) : groupDefs.keys[i];\n        if (fieldValue >= groupDefValue) {\n          const groupDefNextValue = groupDefs.keys[i + 1] && (field.type === 'date' ?\n            new Date(groupDefs.keys[i + 1]) : groupDefs.keys[i + 1]);\n          if (!groupDefNextValue || fieldValue < groupDefNextValue) {\n            group = groupDefs.map[groupDefs.keys[i]];\n          }\n        }\n      }\n    }\n\n    if (!group) {\n      throw new Error('No group found, val: ' + dataItem[field.key] + ' field: ' + field.key);\n    }\n    group.items.push(dataItem);\n    if (group.items.length === 1) {\n      groups.push(group);\n    }\n  });\n  return groups;\n}\n\n// Mimic fetching values from _source as the 'fields' functionality\n// would have done it.\n// We do not use the native 'fields' due to this bug:\n// https://github.com/elastic/elasticsearch/issues/14475\nfunction _getValuesFromSource(source, pathParts) {\n  let values = [];\n  const value = source[pathParts[0]];\n  if (value === undefined) {\n    return [];\n  }\n\n  if (pathParts.length > 1) {\n\n    // recursivity is not over, there remain some path parts\n    if ($.isArray(value)) {\n      value.forEach(function (valueItem) {\n        values = values.concat(_getValuesFromSource(valueItem, pathParts.slice(1)));\n      });\n    } else {\n      values = _getValuesFromSource(value, pathParts.slice(1));\n    }\n  } else {\n\n    // recursivity, we should be in a leaf value\n    if ($.isArray(value)) {\n      values = value;\n    } else {\n      values = [value];\n    }\n  }\n  return values;\n}\n\n// Transform hits from the ES query in to data items for kendo grid\n// The difficulty is that hits can contain inner hits and that some\n// fields can be multi-valued\nfunction _fromHits(hits, fields, innerPath) {\n\n  let dataItems = [];\n  hits.forEach(hit => {\n    const hitSource = hit._source || {};\n    const dataItem = {};\n\n    dataItem.id = [hit._id];\n    Object.keys(fields).filter(fieldKey => {\n      const field = fields[fieldKey];\n\n      // Keep only the fields that are part of this nested/parent/child\n      if (innerPath === undefined) {\n        return !(field.esNestedPath || field.esChildType || field.esParentType);\n      } else {\n        return field.esNestedPath === innerPath ||\n          field.esChildType === innerPath ||\n          field.esParentType === innerPath;\n      }\n    }).forEach(function (fieldKey) {\n      const field = fields[fieldKey];\n      let values = _getValuesFromSource(hitSource, field.esNameSplit);\n\n      // special case field that is a date deep down by displayed as a number\n      if (field.duration) {\n        if (!moment) {\n          throw new Error('Working on durations requires to load momentjs library');\n        }\n      }\n\n      if (field.duration === 'beforeToday') {\n        values = values.map(value => {\n          return moment().startOf('day').diff(moment(value).startOf('day'), 'days');\n        });\n      }\n\n      if (field.duration === 'afterToday') {\n        values = values.map(value => {\n          return moment(value).startOf('day').diff(moment().startOf('day'), 'days');\n        });\n      }\n\n      if (values) {\n        if (field.esMultiSplit) {\n          if (values && values.length) {\n            dataItem[fieldKey] = values;\n          } else {\n            dataItem[fieldKey] = [null];\n          }\n        } else {\n          dataItem[fieldKey] = values.join(field.esMultiSeparator || '\\n');\n        }\n      }\n    });\n\n    // Multiply and fill items based on nesting levels\n    let splittedItems = [dataItem];\n    Object.keys(hit.inner_hits || {}).forEach(function (innerHitKey) {\n      const nestedItems =\n        _fromHits(hit.inner_hits[innerHitKey].hits.hits, fields, innerHitKey);\n      const newSplittedDataItems = [];\n      splittedItems.forEach(function (splittedItem) {\n        if (nestedItems.length) {\n          nestedItems.forEach(function (nestedItem) {\n            const mergedItem = {};\n            Object.keys(nestedItem).forEach(function (key) {\n              mergedItem[key] = nestedItem[key];\n            });\n            Object.keys(splittedItem).forEach(function (key) {\n              mergedItem[key] = splittedItem[key];\n            });\n            newSplittedDataItems.push(mergedItem);\n          });\n        } else {\n          newSplittedDataItems.push(splittedItem);\n        }\n      });\n      splittedItems = newSplittedDataItems;\n    });\n\n    dataItems = dataItems.concat(splittedItems);\n\n  });\n  return _splitMultiValues(dataItems);\n}\n\n// Split lines of data items based on their optionally multipl items\n// Example: [{a:[1,2],b:[3]}] -> [{a:1,b:3},{a:2,b:3}]\nfunction _splitMultiValues(items) {\n  let results = [];\n\n  // Iterates on items in the array and multiply based on multiple values\n  items.forEach(item => {\n    let itemResults = [{}];\n\n    // Iterate on properties of item\n    Object.keys(item).forEach(k => {\n      const partialItemResults = [];\n\n      // Iterate on the multiple values of this property\n      if (item[k] && item[k].constructor === Array) {\n        item[k].forEach(val => {\n          itemResults.forEach(result => {\n\n            // Clone the result to create variants with the different values of current key\n            const newResult = {};\n            Object.keys(result).forEach(k2 => newResult[k2] = result[k2]);\n            newResult[k] = val;\n            partialItemResults.push(newResult);\n          });\n        });\n      } else {\n        itemResults.forEach(result => {\n          result[k] = item[k];\n          partialItemResults.push(result);\n        });\n      }\n      itemResults = partialItemResults;\n    });\n\n    results = results.concat(itemResults);\n  });\n  return results;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/data-items.js\n **/","export const kendo2es = _kendo2es;\n\n// Transform a tree of kendo filters into a tree of ElasticSearch filters\nfunction _kendo2es(kendoFilters, fields) {\n  let filters;\n\n  // logicalConnective can be \"and\" or \"or\"\n  let logicalConnective = 'and';\n\n  if (kendoFilters.operator) {\n    filters = [kendoFilters];\n  } else if (kendoFilters.logic) {\n    logicalConnective = kendoFilters.logic;\n    filters = kendoFilters.filters || [];\n  } else if (kendoFilters.constructor === Array) {\n    filters = kendoFilters;\n  } else {\n    throw new Error('Unsupported filter object: ' + kendoFilters);\n  }\n\n  const esFilters = [];\n  const esNestedFilters = {};\n\n  filters.forEach(filter => {\n    if (filter.logic) {\n      esFilters.push(_kendo2es(filter, fields));\n    } else {\n      const field = fields[filter.field];\n      if (!field) {\n        throw new Error('Unknown field in filter: ' + filter.field);\n      }\n      let esFilter = {\n        query: {\n          query_string: {\n            query: _filterParam(filter, fields),\n            // support uppercase/lowercase and accents\n            analyze_wildcard: true\n          }\n        }\n      };\n      if (field.esNestedPath) {\n        const esNestedFilter = esNestedFilters[field.esNestedPath] || {\n          nested: {\n            path: field.esFullNestedPath,\n            filter: {}\n          }\n        };\n        esNestedFilter.nested.filter[logicalConnective] = esNestedFilter.nested.filter[logicalConnective] || {\n          filters: []\n        };\n        esNestedFilter.nested.filter[logicalConnective].filters.push(esFilter);\n        if (!esNestedFilters[field.esNestedPath]) {\n          esFilter = esNestedFilters[field.esNestedPath] = esNestedFilter;\n        } else {\n          esFilter = null;\n        }\n      } else if (field.esParentType) {\n        esFilter = {\n          has_parent: {\n            type: field.esParentType,\n            filter: esFilter\n          }\n        };\n      } else if (field.esChildType) {\n        esFilter = {\n          has_child: {\n            type: field.esChildType,\n            filter: esFilter\n          }\n        };\n      }\n\n      if (esFilter) {\n        esFilters.push(esFilter);\n      }\n\n    }\n  });\n\n  const result = {};\n  result[logicalConnective] = {\n    filters: esFilters\n  };\n  return result;\n}\n\n// Transform a single kendo filter in a string\n// that can be used to compose a ES query_string query\nfunction _filterParam(kendoFilter, fields) {\n\n  // Boolean filter seems to forget the operator sometimes\n  kendoFilter.operator = kendoFilter.operator || 'eq';\n\n  // Use the filter field name except for contains\n  // that should use classical search instead of regexp\n  const field = fields[kendoFilter.field];\n\n  // special case field that is a date deep down by displayed as a number\n  if (field.duration) {\n    if (!moment) {\n      throw new Error('Working on durations requires to load momentjs library');\n    }\n  }\n\n  if (field.duration === 'beforeToday') {\n    kendoFilter.value = moment().startOf('day').subtract(kendoFilter.value, 'days').format();\n    if (kendoFilter.operator === 'lt') kendoFilter.operator = 'gt';\n    else if (kendoFilter.operator === 'lte') kendoFilter.operator = 'gte';\n    else if (kendoFilter.operator === 'gt') kendoFilter.operator = 'lt';\n    else if (kendoFilter.operator === 'gte') kendoFilter.operator = 'lte';\n  }\n\n  if (field.duration === 'afterToday') {\n    kendoFilter.value = moment().startOf('day').add(kendoFilter.value, 'days').format();\n  }\n\n  let fieldName;\n  if (kendoFilter.operator === 'search') {\n    fieldName = field.esSearchName;\n  } else {\n    fieldName = field.esFilterName;\n  }\n\n  const fieldEscaped = _asESParameter(fieldName);\n  const valueEscaped = _asESParameter(kendoFilter.value, kendoFilter.operator);\n\n  const simpleBinaryOperators = {\n    eq: '',\n    search: '',\n    lt: '<',\n    lte: '<=',\n    gt: '>',\n    gte: '>='\n  };\n\n  if (simpleBinaryOperators[kendoFilter.operator] !== void 0) {\n    const esOperator = simpleBinaryOperators[kendoFilter.operator];\n    return fieldEscaped + ':' + esOperator + valueEscaped;\n  } else {\n    let expression;\n    switch (kendoFilter.operator) {\n      case 'neq':\n        return 'NOT (' + fieldEscaped + ':' + valueEscaped + ')';\n      case 'contains':\n        return '(' + fieldEscaped + ':*' + valueEscaped + '*)';\n      case 'doesnotcontain':\n        return 'NOT (' + fieldEscaped + ':*' + valueEscaped + '*)';\n      case 'startswith':\n        return fieldEscaped + ':' + valueEscaped + '*';\n      case 'endswith':\n        return fieldEscaped + ':*' + valueEscaped;\n      case 'missing':\n        if (field.esNestedPath || field.esParentType || field.esChildType) {\n          // missing in a nested document should be implemented as a \"not nested exists\"\n          // but this is not really doable when mixing with other filters\n          // see https://github.com/elastic/elasticsearch/issues/3495\n          throw new Error('missing filter is not supported on nested fields');\n        }\n        expression = '_missing_:' + fieldEscaped;\n        if (field.type === 'string') {\n          expression += ' OR (' + fieldEscaped + ':\"\")';\n        }\n        return expression;\n      case 'exists':\n        expression = '_exists_:' + fieldEscaped;\n        if (field.type === 'string') {\n          expression += ' AND NOT(' + fieldEscaped + ':\"\")';\n        }\n        return expression;\n      default:\n        throw new Error('Unsupported Kendo filter operator: ' + kendoFilter.operator);\n    }\n  }\n}\n\n// Escape values so that they are suitable as an elasticsearch query_string query parameter\nconst escapeValueRegexp = /[+\\-&|!()\\{}\\[\\]^:\"~*?:\\/ ]/g;\nconst escapeSearchValueRegexp = /[+\\-&|!()\\{}\\[\\]^:~:\\/]/g;\n\nfunction _asESParameter(value, operator) {\n  if (value.constructor === Date) {\n    value = value.toISOString();\n  } else if (typeof value === 'boolean' || typeof value === 'number') {\n    value = '' + value;\n  }\n\n  // For the special 'search' operator we allow some wildcard and other characters\n  if (operator === 'search') {\n    value = value.replace('\\\\', '\\\\\\\\');\n    if (((value.match(/\"/g) || []).length % 2) === 1) {\n      value = value.replace(/\"/g, '\\\\\"');\n    }\n    value = value.replace(escapeSearchValueRegexp, '\\\\$&');\n    return value;\n  }\n  return value.replace('\\\\', '\\\\\\\\').replace(escapeValueRegexp, '\\\\$&');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/filters.js\n **/","export const fromMapping = _fromMapping;\nexport const fill = _fill;\nexport const nestedFields = _nestedFields;\n\n// Transform a mapping definition from ElasticSearch into a kendo fields map\n// This utility function is exposed as it can be interesting to use it before instantiating\n// the actual datasource\n// @param mapping - An elasticsearch mapping\nfunction _fromMapping(\n  mapping, model, fields = {}, prefix = '', esPrefix, nestedPath) {\n  Object.keys(mapping.properties || {}).forEach(propertyKey => {\n    const property = mapping.properties[propertyKey];\n    const curedPropertyKey = asKendoPropertyKey(propertyKey);\n    const prefixedName = prefix ? prefix + '_' + curedPropertyKey : curedPropertyKey;\n    const esName = esPrefix ? esPrefix + '.' + propertyKey : propertyKey;\n\n    if (property.type === 'nested') {\n      // Case where the property is a nested object\n      const subNestedPath = nestedPath ? nestedPath + '.' + esName : esName;\n      _fromMapping(property, model, fields, prefixedName, '', subNestedPath);\n    } else if (property.properties) {\n      // Case where the property is a non nested object with properties\n      _fromMapping(property, model, fields, prefixedName, esName, nestedPath);\n    } else if (property.type === 'object') {\n      // Case where the property is a non nested object with zero subproperties. do nothing.\n    } else {\n      // Finally case of a leaf property\n      const field = fields[prefixedName] = fields[prefixedName] || {};\n\n      // if the field was already defined with a nested path,\n      // then we are in the case of field both nested and included in parent\n      // then we should not consider it as a real leaf property\n      if (!field.esNestedPath) {\n        field.type = field.type || property.type;\n\n        // ES supports a variety of numeric types. In JSON and kendo it is simply 'number'.\n        if (['float', 'double', 'integer', 'long', 'short', 'byte'].indexOf(field.type) !== -1) {\n          field.type = 'number';\n        }\n\n        // Default is splitting data lines except for string fields\n        if (field.type !== 'string') {\n          field.esMultiSplit = true;\n        }\n\n        if (nestedPath) {\n          field.esNestedPath = nestedPath;\n        }\n        field.esName = esName;\n\n        // When the field is not analyzed, the default string subfields should not be applied.\n        if (property.index === 'not_analyzed') {\n          field.esSearchSubField = null;\n          field.esFilterSubField = null;\n          field.esAggSubField = null;\n        }\n      }\n    }\n  });\n\n  _fill(fields, model);\n\n  return fields;\n};\n\n// Associate Kendo field names to ElasticSearch field names.\n// We have to allow ElasticSearch field names to be different\n// because ES likes an \"@\" and/or dots in field names while Kendo fails on that.\n// Filtering and aggregating can be based on a a different field if esFilterName\n// or esAggName are defined or on a subfield if esFilterSubField or esAggSubField are defined.\n// Typical use case is the main field is analyzed, but it has a subfield that is not\n// (or only with a minimal analyzer)\nfunction _fill(fields, model = {}) {\n  for (const k in fields) {\n    if (fields.hasOwnProperty(k)) {\n      const field = fields[k];\n      field.key = k;\n      field.esName = field.esName || k;\n      field.esNameSplit = field.esName.split('.');\n      if (field.esNestedPath) {\n        field.esFullNestedPath = field.esNestedPath;\n        if (model.esMappingKey) {\n          field.esFullNestedPath = model.esMappingKey + '.' + field.esFullNestedPath;\n        }\n      }\n      if (!field.esSearchName) {\n        field.esSearchName = field.esName;\n        if (field.hasOwnProperty('esSearchSubField')) {\n          if (field.esSearchSubField) {\n            field.esSearchName += '.' + field.esSearchSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.search) {\n          field.esSearchName += '.' + model.esStringSubFields.search;\n        }\n        if (field.esNestedPath) {\n          field.esSearchName = field.esNestedPath + '.' + field.esSearchName;\n        }\n      }\n      if (!field.esFilterName) {\n        field.esFilterName = field.esName;\n        if (field.hasOwnProperty('esFilterSubField')) {\n          if (field.esFilterSubField) {\n            field.esFilterName += '.' + field.esFilterSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.filter) {\n          field.esFilterName += '.' + model.esStringSubFields.filter;\n        }\n        if (field.esNestedPath) {\n          field.esFilterName = field.esNestedPath + '.' + field.esFilterName;\n        }\n      }\n      if (!field.esAggName) {\n        field.esAggName = field.esName;\n        if (field.hasOwnProperty('esAggSubField')) {\n          if (field.esAggSubField) {\n            field.esAggName += '.' + field.esAggSubField;\n          }\n        } else if (field.type === 'string' &&\n          model.esStringSubFields &&\n          model.esStringSubFields.agg) {\n          field.esAggName += '.' + model.esStringSubFields.agg;\n        }\n        if (field.esNestedPath) {\n          field.esAggName = field.esFullNestedPath + '.' + field.esAggName;\n        }\n      }\n    }\n  }\n}\n\n// Get a property key and transform it in a suitable key for kendo\n// the constraint is that kendo needs a key suitable for javascript object's dot notation\n// i.e a valid js identifier with alphanumeric chars + '_' and '$'\nfunction asKendoPropertyKey(value) {\n  return value.replace(/[^a-zA-z0-9_$]/g, '_');\n}\n\n// Get sets of nesting levels and matching groups of fields\nfunction _nestedFields(fields) {\n  const _result = {};\n  const _subTypes = {};\n  Object.keys(fields).forEach(fieldKey => {\n    const field = fields[fieldKey];\n    if (field.esNestedPath) {\n      _result[field.esNestedPath] = _result[field.esNestedPath] || [];\n      _result[field.esNestedPath].push(field.esName);\n    }\n    if (field.esParentType) {\n      _subTypes[field.esParentType] = _subTypes[field.esParentType] || [];\n      _subTypes[field.esParentType].push(field.esName);\n    }\n    if (field.esChildType) {\n      _subTypes[field.esChildType] = _subTypes[field.esChildType] || [];\n      _subTypes[field.esChildType].push(field.esName);\n    }\n  });\n\n  return [_result, _subTypes];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/fields.js\n **/"],"sourceRoot":""}